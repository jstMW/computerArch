
<!-- saved from url=(0056)http://www.csi.ucd.ie/staff/jcarthy/home/alp/alp2-3.html -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">

<META name="Generator" content="Microsoft Word 98">
<TITLE>Input and Output (I/O) in 8086 Assembly Language</TITLE>
</HEAD><BODY>

<B><FONT face="Times" size="5"><P align="JUSTIFY">Input and Output (I/O) in 8086 Assembly Language</P>
</FONT></B><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">Each microprocessor provides instructions for I/O with the devices that are attached to it, e.g. the keyboard and screen. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The 8086 provides the instructions </FONT><FONT face="Courier" size="5">in</FONT><FONT face="Times" size="5"> for input and </FONT><FONT face="Courier" size="5">out</FONT><FONT face="Times" size="5"> for output. These instructions are quite complicated to use, so we usually use the operating system to do I/O for us instead. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The operating system provides a range of I/O subprograms, in much the same way as there is an extensive library of subprograms available to the C programmer. In C, to perform an I/O operation, we call a subprogram using its name to indicate its operations, e.g. </FONT><FONT face="Courier" size="5">putchar()</FONT><FONT face="Times" size="5">, </FONT><FONT face="Courier" size="5">printf()</FONT><FONT face="Times" size="5">, </FONT><FONT face="Courier" size="5">getchar()</FONT><FONT face="Times" size="5">. In addition we may pass a parameter to the subprogram, for example the character to be displayed by </FONT><FONT face="Courier" size="5">putchar()</FONT><FONT face="Times" size="5"> is passed as a parameter e.g. </FONT><FONT face="Courier" size="5">putchar(c)</FONT><FONT face="Times" size="5">. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">In assembly language we must have a mechanism to call the operating system to carry out I/O. </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">In addition we must be able to tell the operating system what kind of I/O operation we wish to carry out, e.g. to read a character from the keyboard, to display a character or string on the screen or to do disk I/O. </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">Finally, we must have a means of passing parameters to the operating subprogram. </P>
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">In 8086 assembly language, we do not call operating system subprograms by name, instead, we use a software interrupt mechanism </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">An interrupt signals the processor to suspend its current activity (i.e. running your program) and to pass control to an interrupt service program (i.e. part of the operating system). </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">A software interrupt is one generated by a program (as opposed to one generated by hardware). </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The 8086 </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5"> instruction generates a software interrupt. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">It uses a single operand which is a number indicating which MS-DOS subprogram is to be invoked. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">For I/O and some other operations, the number used is </FONT><B><FONT face="Courier" size="5">21h</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5">. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">Thus, the instruction </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5"> </FONT><FONT face="Courier" size="5">21h</FONT><FONT face="Times" size="5"> transfers control to the operating system, to a subprogram that handles I/O operations. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">This subprogram handles a variety of I/O operations by calling appropriate subprograms. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">This means that you must also specify which I/O operation (e.g. read a character, display a character) you wish to carry out. This is done by placing a specific number in a register. The </FONT><FONT face="Courier" size="5">ah</FONT><FONT face="Times" size="5"> register is used to pass this information.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">For example, the subprogram to display a character is subprogram number <B>2h</B>. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">This number must be stored in the </FONT><FONT face="Courier" size="5">ah</FONT><FONT face="Times" size="5"> register. We are now in a position to describe character output. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">When the I/O operation is finished, the interrupt service program terminates and our program will be resumed at the instruction following </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5">. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<B><P align="JUSTIFY">3.3.1 Character Output</P>
</B></FONT><P align="JUSTIFY"><FONT face="Times" size="5">The task here is to display a single character on the screen. There are three elements involved in carrying out this operation using the </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5"> instruction:</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">1.	 We specify the character to be displayed. This is done by storing the character’s ASCII code in a specific 8086 register. In this case we use the </FONT><B><FONT face="Courier" size="5">dl</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> register, i.e. we use </FONT><FONT face="Courier" size="5">dl</FONT><FONT face="Times" size="5"> to pass a parameter to the output subprogram.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">2.	 We specify which of MS-DOS’s I/O subprograms we wish to use. The subprogram to display a character is subprogram number </FONT><B><FONT face="Courier" size="5">2h</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5">. This number is stored in the </FONT><FONT face="Courier" size="5">ah</FONT><FONT face="Times" size="5"> register.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">3.	 We request MS-DOS to carry out the I/O operation using the </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5"> instruction. This means that we <B>interrupt</B> our program and transfer control to the MS-DOS subprogram that we have specified using the </FONT><FONT face="Courier" size="5">ah</FONT><FONT face="Times" size="5"> register. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<B></B></FONT><P align="JUSTIFY"><FONT face="Times" size="5"><B>Example 1: </B>Write a code fragment to display the character </FONT><FONT face="Courier" size="5">’a’</FONT><FONT face="Times" size="5"> on the screen:</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">C version:</P>
</FONT><FONT face="Courier" size="4"><P>		putchar( ‘a‘ ) ;</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">8086 version:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>	mov	dl, ‘a‘	; dl = ‘a‘ </P>
<P>	mov	ah, 2h	; character output subprogram</P>
<P>	int	21h		; call ms-dos output character </P>
</FONT><FONT face="Courier" size="5"><P align="JUSTIFY"></P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY">As you can see, this simple task is quite complicated in assembly language. </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<B><P align="JUSTIFY">3.3.2 Character Input</P>
</B><P align="JUSTIFY">The task here is to read a single character from the keyboard. There are also three elements involved in performing character input:</P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">1.	As for character output, we specify which of MS-DOS’s I/O subprograms we wish to use, i.e. the character input from the keyboard subprogram. This is MS-DOS subprogram number <B>1h</B>. This number must be stored in the </FONT><FONT face="Courier" size="5">ah</FONT><FONT face="Times" size="5"> register. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">2.	We call MS-DOS to carry out the I/O operation using the </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5"> instruction as for character output. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">3.	The MS-DOS subprogram uses the </FONT><FONT face="Courier" size="5">al</FONT><FONT face="Times" size="5"> register to store the character it reads from the keyboard. </FONT></P><FONT face="Times" size="5">
<B></B><P align="JUSTIFY"><B>Example 2: </B>Write a code fragment to read a character from the keyboard:</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">C version:</P>
</FONT><FONT face="Courier" size="5"><P>		c = getchar() ;</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">8086 Version:</P>
</FONT><FONT face="Courier" size="5"><P>	mov	ah, 1h	; keyboard input subprogram</P>
<P>	int	21h<B>		</B>; character input </P>
<P>	<B>			</B>; character is stored in al</P>
<P>	mov	c, al	; copy character from al to c</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">The following example combines the two previous ones, by reading a character from the keyboard and displaying it.</P>
<P align="JUSTIFY"></P>
<B></B><P align="JUSTIFY"><B>Example 3: </B>Reading and displaying a character:</P>
<P align="JUSTIFY"> </P>
<P align="JUSTIFY">C version:</P>
</FONT><FONT face="Courier" size="5"></FONT><P><FONT face="Courier" size="5">		</FONT><FONT face="Courier" size="4">c = getchar() ;</FONT></P><FONT face="Courier" size="4">
<P>		putchar( c ) ;</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">8086 version:</P>
</FONT><FONT face="Courier" size="4">
</FONT><FONT face="Courier" size="5"><P>	mov	ah, 1h	; keyboard input subprogram</P>
<P>	int	21h		; read character into al</P>

<P>	mov	dl, al	; copy character to dl</P>

<P>	mov	ah, 2h	; character output subprogram</P>
<P>	int	21h		; display character in dl</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<B><P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">A Complete Program</P>
</B><P align="JUSTIFY">We are now in a position to write a complete 8086 program. You must use an <B>editor</B> to enter the program into a file. The process of using the editor (<B>editing</B>) is a basic form of word processing. This skill has no relevance to programming. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">We use Microsoft’s </FONT><FONT face="Courier" size="5">MASM</FONT><FONT face="Times" size="5"> and </FONT><FONT face="Courier" size="5">LINK</FONT><FONT face="Times" size="5"> programs for assembling and linking 8086 assembly language programs. </FONT><FONT face="Courier" size="5">MASM</FONT><FONT face="Times" size="5"> program files should have names with the <B>extension</B> (3 characters after period) </FONT><FONT face="Courier" size="5">asm</FONT><FONT face="Times" size="5">. We will call our first program </FONT><FONT face="Courier" size="5">prog1.asm</FONT><FONT face="Times" size="5">, it displays the letter </FONT><FONT face="Courier" size="5">‘a‘</FONT><FONT face="Times" size="5"> on the screen.</FONT><FONT face="Courier" size="5"> </FONT><FONT face="Times" size="5">(You may use any name you wish. It is a good idea to choose a meaningful file name). Having entered and saved the program using an editor, you must then use the </FONT><FONT face="Courier" size="5">MASM</FONT><FONT face="Times" size="5"> and </FONT><FONT face="Courier" size="5">LINK</FONT><FONT face="Times" size="5"> commands to translate it to machine code so that it may be executed as follows:</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>	C&gt; <B>masm</B> prog1</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">If you have syntax errors, you will get error messages at this point. You then have to edit your program, correct them and repeat the above command, otherwise proceed to the </FONT><FONT face="Courier" size="5">link</FONT><FONT face="Times" size="5"> command, pressing Return in response to prompts for file names from </FONT><FONT face="Courier" size="5">masm</FONT><FONT face="Times" size="5"> or </FONT><FONT face="Courier" size="5">link</FONT><FONT face="Times" size="5">.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>	C&gt; <B>link</B> prog1</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">To execute the program, simply enter the program name and press the Return key:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>	C&gt; prog1</P>
<P>	a</P>
<P>	C&gt;</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<B></B><P align="JUSTIFY"><B>Example 4: </B>A complete program to display the letter ‘a‘ on the screen:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>; prog1.asm: displays the character ‘a’ on the screen</P>
<P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>

<P>		.model small</P>
<P>		.stack 100h</P>

<P>		.code</P>
<P>start:</P>
<P>		mov	dl, ‘a’	; store ascii code of ‘a’ in dl</P>

<P>		mov	ah, 2h	; ms-dos character output function</P>
<P>		int	21h		; displays character in dl register</P>

<P>		mov	ax, 4c00h ; return to ms-dos</P>
<P>		int	21h</P>
<P>		end	start</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">The first three lines of the program are comments to give the name of the file containing the program, explain its purpose, give the name of the author and the date the program was written. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The first two directives, </FONT><FONT face="Courier" size="5">.model</FONT><FONT face="Times" size="5"> and </FONT><FONT face="Courier" size="5">.stack</FONT><FONT face="Times" size="5"> are concerned with how your program will be stored in memory and how large a stack it requires. The third directive, </FONT><FONT face="Courier" size="5">.code</FONT><FONT face="Times" size="5">, indicates where the program instructions (i.e. the program code) begin. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">For the moment, suffice it to say that you need to start all assembly languages programs in a particular format (not necessarily that given above.</P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5"> Your program must also finish in a particular format, the </FONT><FONT face="Courier" size="5">end</FONT><FONT face="Times" size="5"> directive indicates where your program finishes. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">In the middle comes the code that you write yourself. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">You must also specify where your program starts, i.e. which is the <B>first</B> instruction to be executed. This is the purpose of the label, </FONT><FONT face="Courier" size="5">start</FONT><FONT face="Times" size="5">. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">(Note: We could use any label, e.g. </FONT><FONT face="Courier" size="5">begin</FONT><FONT face="Times" size="5"> in place of </FONT><FONT face="Courier" size="5">start</FONT><FONT face="Times" size="5">). </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">This same label is also used by the </FONT><FONT face="Courier" size="5">end</FONT><FONT face="Times" size="5"> directive. When a program has finished, we return to the operating system. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">Like carrying out an I/O operation, this is also accomplished by using the </FONT><FONT face="Courier" size="5">int</FONT><FONT face="Times" size="5"> instruction. This time MS-DOS subprogram number </FONT><FONT face="Courier" size="5">4c00h </FONT><FONT face="Times" size="5">is used. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">It is the subprogram to terminate a program and return to MS-DOS. Hence, the instructions:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>	mov	ax, 4c00h	; Code for return to MS-DOS</P>
<P>	int	21H			; Terminates program </P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">terminate a program and return you to MS-DOS.</P>
<P align="JUSTIFY"></P>
<B><P align="JUSTIFY">Time-saving Tip</P>
</B></FONT><P align="JUSTIFY"><FONT face="Times" size="5">Since your programs will start and finish using the same format, you can save yourself time entering this code for each program. You create a template program called for example, </FONT><FONT face="Courier" size="5">template.asm</FONT><FONT face="Times" size="5">, which contains the standard code to start and finish your assembly language programs. Then, when you wish to write a new program, you copy this template program to a new file, say for example, </FONT><FONT face="Courier" size="5">prog2.asm</FONT><FONT face="Times" size="5">, as follows (e.g. using the MS-DOS copy command):</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>		C&gt; copy template.asm io2.asm</P>
</FONT><FONT face="Times" size="4"><P align="JUSTIFY"></P>
</FONT><FONT face="Times" size="5"></FONT><P align="JUSTIFY"><FONT face="Times" size="5">You then edit </FONT><FONT face="Courier" size="5">prog2.asm </FONT><FONT face="Times" size="5">and enter your code in the appropriate place.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<B></B><P align="JUSTIFY"><B>Example 3.9: </B>The following template could be used for our first programs:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P align="JUSTIFY">; &lt;filename goes here&gt;.asm: </P>
<P align="JUSTIFY">; Author: </P>
<P align="JUSTIFY">; Date: </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">		.model small</P>
<P align="JUSTIFY">		.stack 100h</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">		.code</P>
<P align="JUSTIFY">start:</P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Courier" size="4">;</FONT><B><I><FONT face="Courier" size="5">		&lt; your code goes here &gt;</FONT></I></B></P><B><I><FONT face="Courier" size="5">
</FONT></I></B><I><FONT face="Courier" size="5"></FONT></I><FONT face="Courier" size="5"></FONT><FONT face="Courier" size="4"><P align="JUSTIFY"></P>
<P align="JUSTIFY">		mov	ax, 4c00h ; return to ms-dos</P>
<P align="JUSTIFY">		int	21h</P>
<P align="JUSTIFY">		end	start</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">To write a new program, you enter your code in the appropriate place as indicated above.</P>
<I><P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
</I><B><P align="JUSTIFY">&nbsp;</P>
</B><P align="JUSTIFY"><B>Example 3.10: </B>Write a program to read a character from the keyboard and display it on the screen:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>; prog2.asm: read a character and display it </P>
</FONT><FONT face="Courier" size="5"><P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>

<P>		.model small</P>
<P>		.stack 100h</P>

<P>		.code</P>
<P>start:</P>

<P>	mov	ah, 1h	; keyboard input subprogram</P>
<P>	int	21h		; read character into al</P>

<P>	mov	dl, al	</P>

<P>	mov	ah, 2h	; display subprogram</P>
<P>	int	21h		; display character in dl</P>

<P>	mov	ax, 4c00h 	 ; return to ms-dos</P>
<P>	int	21h</P>

<P>	end	start</P>
</FONT><B><FONT face="Times" size="4"><P align="JUSTIFY"></P>
</FONT></B><FONT face="Times" size="4"></FONT><FONT face="Times" size="5"><P align="JUSTIFY">Assuming you enter the letter ‘B’ at the keyboard when you execute the program, the output will appear as follows:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>	C&gt; prog2</P>
<P>	<B>B</B>B</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">Rewrite the above program to use a prompt:</P>
</FONT><FONT face="Courier" size="4"><P>			C&gt;prog4</P>
<P>			?<B>B</B> B</P>
</FONT><FONT face="Times" size="5">
</FONT><FONT face="Courier" size="4"><P>; prog4.asm: prompt user with ? </P>
<P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>
<P>		.model small</P>
<P>		.stack 100h</P>
<P>		.code</P>
<P>start:</P>
<P>; display ?</P>
<P>		mov	dl, ‘?’		; copy ? to dl</P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; call ms-dos to display ?</P>

<P>; read character from keyboard</P>
<P>		mov	ah, 1h	 	; keyboard input subprogram</P>
<P>		int	21h			; read character into al</P>

<P>; save character entered while we display a space</P>
<P>		mov	bl, al		; copy character to bl</P>

<P>; display space character</P>
<P>		mov	dl, ‘ ’		; copy space to dl</P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; call ms-dos to display space</P>

<P>; display character read from keyboard</P>
<P>		mov	dl, bl		; copy character entered to dl</P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; display character in dl</P>

<P>		mov	ax, 4c00h 	 	; return to ms-dos</P>
<P>		int	21h</P>
<P>		end	start</P>
</FONT><B><FONT face="Times" size="4"><P align="JUSTIFY"></P>
</FONT><FONT face="Times" size="5"></FONT></B><FONT face="Times" size="5"></FONT><P align="JUSTIFY"><FONT face="Times" size="5"><B>Note</B>: In this example we must save the character entered (we save it in </FONT><FONT face="Courier" size="5">bl</FONT><FONT face="Times" size="5">) so that we can use </FONT><FONT face="Courier" size="5">ax</FONT><FONT face="Times" size="5"> for the display subprogram number.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<B></B><P align="JUSTIFY"><B>Example 3.12:</B> Modify the previous program so that the character entered, is displayed on the following line giving the effect:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>	C&gt; io4</P>
<P>	? <B>x</B> </P>
<P>	x</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY">In this version, we need to output the Carriage Return and Line-feed characters. </P>
<P align="JUSTIFY"></P>
<B></B><P align="JUSTIFY"><B>Carriage Return</B>, (ASCII 13D) is the control character to bring the cursor to the start of a line.</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<B></B><P align="JUSTIFY"><B>Line-feed</B> (ASCII 10D) is the control character that brings the cursor down to the next line on the screen. </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">(We use the abbreviations CR and LF to refer to Return and Line-feed in comments.)</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">In C and Java programs we use the newline character ‘\n’ to generate a new line which in effect causes a Carriage Return and Linefeed to be transmitted to your screen.</P>
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">&nbsp;</P>
</FONT><FONT face="Courier" size="2"><P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">&nbsp;</P>
</FONT><FONT face="Courier" size="4"><P align="JUSTIFY">; io4.asm: 	prompt user with ?, </P>
<P>;	read character and display the CR, LF characters </P>
<P>;	followed by the character entered. </P>
<P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>

<P>		.model small</P>
<P>		.stack 100h</P>
<P>		.code</P>
<P>start:</P>
<P>; display ?</P>
<P>		mov	dl, ‘?’		; copy ? to dl</P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; display ?</P>

<P>; read character from keyboard</P>
<P>		mov	ah, 1h		; keyboard input subprogram</P>
<P>		int	21h			; read character into al </P>

<P>; save character while we display a Return and Line-feed</P>
<P>		mov	bl, al		; save character in bl</P>

<P>;display Return</P>
<P>		mov	dl, 13d		; dl = CR </P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; display CR</P>

<P>;display Line-feed</P>
<P>		mov	dl, 10d		; dl = LF </P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; display LF</P>

<P>; display character read from keyboard</P>
<P>		mov	dl, bl		; copy character to dl</P>
<P>		mov	ah, 2h		; display subprogram</P>
<P>		int	21h			; display character in dl</P>

<P>		mov	ax, 4c00h 		; return to ms-dos</P>
<P>		int	21h</P>
<P>		end	start</P>
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><B><FONT face="Times" size="5"></FONT></B><FONT face="Times" size="5"><P align="JUSTIFY"><B>Note</B>: Indentation and documentation, as mentioned before, are the responsibility of the programmer. Program 3.13 below is a completely valid way of entering the program presented earlier in Example 3.12:</P>
<P align="JUSTIFY"></P>
<B></B><P align="JUSTIFY"><B>Example 3.13</B> <B>without indentation and comments</B>.</P>
</FONT><B><FONT face="Times" size="6"><P align="JUSTIFY"></P>
</FONT></B><FONT face="Times" size="6"></FONT><FONT face="Courier" size="5"><P>.model small</P>
<P>.stack 100h</P>
<P>.code</P>
<P>start:</P>
<P> mov	dl,‘?’		</P>
<P> mov	ah,2h		</P>
<P> int	21h			</P>
<P> mov	ah,1h	</P>
<P> int	21h	</P>
<P> mov	bl,al	</P>
<P> mov	dl,13d		</P>
<P> mov	ah,2h		</P>
<P> int	21h		</P>
<P> mov	dl,10d		</P>
<P> mov	ah,2h		</P>
<P> int	21h	</P>
<P> mov	dl,bl	</P>
<P> mov	ah,2h		</P>
<P> int	21h			</P>
<P> mov	ax,4c00h 	</P>
<P> int	21h</P>
<P>end	start</P>
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><B><FONT face="Times" size="5"><P align="JUSTIFY">Which program is easier to read and understand ?</P>
</FONT></B><FONT face="Times" size="5"></FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><B><FONT face="Times" size="5"><P align="JUSTIFY">String Output</P>
</FONT></B><FONT face="Times" size="5"><P align="JUSTIFY">A string is a list of characters treated as a unit. In programming languages we denote a string constant by using quotation marks, e.g. "Enter first number". </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">In 8086 assembly language, single or double quotes may be used. </P>
<P align="JUSTIFY"></P>
<B><I><P align="JUSTIFY">Defining String Variables</P>
</I></B><I></I></FONT><P align="JUSTIFY"><FONT face="Times" size="5">The following 3 definitions are equivalent ways of defining a string </FONT><FONT face="Courier" size="5">"abc"</FONT><FONT face="Times" size="5">:</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>version1	db	"abc"			; string constant</P>
<P>version2	db	‘a’, ‘b’, ‘c’	; character constants</P>
<P>version3	db	97, 98, 99		; ASCII codes</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">The first version uses the method of high level languages and simply encloses the string in quotes. This is the preferred method.</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">The second version defines a string by specifying a list of the character constants that make up the string. </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">The third version defines a string by specifying a list of the ASCII codes that make up the string </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">We may also combine the above methods to define a string as in the following example:</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>	message	db	"Hello world", 13, 10, ‘$’</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The string </FONT><FONT face="Courier" size="5">message</FONT><FONT face="Times" size="5"> contains ‘Hello world’<B> </B>followed by Return (ASCII 13), Line-feed (ASCII 10) and the </FONT><FONT face="Courier" size="5">‘$’</FONT><B><FONT face="Times" size="5"> </FONT></B><FONT face="Times" size="5">character. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">This method is very useful if we wish to include control characters (such as Return) in a string. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">We terminate the string with the </FONT><FONT face="Courier" size="5">‘$’</FONT><FONT face="Times" size="5"> character because there is an MS-DOS subprogram (number </FONT><FONT face="Courier" size="5">9h</FONT><FONT face="Times" size="5">) for displaying strings which expects the string to be terminated by the </FONT><FONT face="Courier" size="5">‘$’</FONT><FONT face="Times" size="5"> character. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">It is important to understand that </FONT><B><FONT face="Courier" size="5">db</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> is not an assembly language instruction. It is called a <B>directive</B>. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">A directive tells the assembler to do something, when translating your program to machine code. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The </FONT><B><FONT face="Courier" size="5">db</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> directive tells the assembler to store one or more bytes in a <B>named memory location</B>. From the above examples, the named locations are </FONT><FONT face="Courier" size="5">version1, version2, version3</FONT><FONT face="Times" size="5"> and </FONT><FONT face="Courier" size="5">message</FONT><FONT face="Times" size="5">. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">These are in effect <B>string variables</B>.</P>
</FONT><B><FONT face="Times" size="6"><P align="JUSTIFY"></P>
</FONT></B><FONT face="Times" size="6"></FONT><FONT face="Times" size="5"><P align="JUSTIFY">In order to display a string we must know where the string begins and ends. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The beginning of string is given by obtaining its address using the </FONT><FONT face="Courier" size="5">offset</FONT><FONT face="Times" size="5"> operator. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">The end of a string may be found by either knowing in advance the length of the string or by storing a special character at the end of the string which acts as a <B>sentinel</B>. </P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">We have already used MS-DOS subprograms for character I/O (number <B>1h</B> to read a single character from the keyboard and number <B>2h </B>to display a character on the screen.) </P>
<P align="JUSTIFY"></P>
<B><I><P align="JUSTIFY">String Output</P>
</I></B><I></I></FONT><P align="JUSTIFY"><FONT face="Times" size="5">MS-DOS provides subprogram number <B>9h</B> to display strings which are terminated by the </FONT><B><FONT face="Courier" size="5">‘$’</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> character. In order to use it we must:</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">1	Ensure the string is terminated with the </FONT><FONT face="Courier" size="5">‘$’</FONT><FONT face="Times" size="5"> character.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">2	Specify the string to be displayed by storing its address in the </FONT><B><FONT face="Courier" size="5">dx</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> register.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">3	Specify the string output subprogram by storing </FONT><FONT face="Courier" size="5">9h</FONT><FONT face="Times" size="5"> in </FONT><FONT face="Courier" size="5">ah.</FONT></P><FONT face="Courier" size="5">
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><FONT face="Times" size="5"></FONT><P align="JUSTIFY"><FONT face="Times" size="5">4	Use </FONT><FONT face="Courier" size="5">int 21h</FONT><FONT face="Times" size="5"> to call MS-DOS to execute subprogram </FONT><FONT face="Courier" size="5">9h.</FONT></P><FONT face="Courier" size="5">
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The following code illustrates how the string </FONT><FONT face="Courier" size="5">‘Hello world’</FONT><FONT face="Times" size="5">, followed by the Return and Line-feed characters, can be displayed. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<B><P align="JUSTIFY">&nbsp;</P>
</B></FONT><P align="JUSTIFY"><FONT face="Times" size="5"><B>Example 3.14:</B> Write a program to display the message </FONT><FONT face="Courier" size="5">‘Hello world’</FONT><FONT face="Times" size="5"> followed by Return and Line-feed :</FONT></P><FONT face="Times" size="5">
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>; io8.asm: Display the message ‘Hello World’</P>
<P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>

<P>		.model small</P>
<P>		.stack 100h</P>

<P>			.data</P>
<P>message		db		‘Hello World‘, 13, 10, ‘$‘</P>
<P>							 </P>
<P>			.code</P>
<P>start:		</P>
<P>			mov	ax, @data</P>
<P>			mov	ds, ax</P>

<P>; copy address of message to dx</P>
<P>			mov	dx, offset message	</P>

<P>			mov 	ah, 9h		; string output</P>
<P>			int 	21h			; display string</P>

<P>			mov	ax, 4c00h</P>
<P>			int 	21h</P>

<P>			end	start</P>
</FONT><FONT face="Times">
<B><P align="JUSTIFY">&nbsp;</P>
</B></FONT><FONT face="Times" size="5"></FONT><P align="JUSTIFY"><FONT face="Times" size="5">In this example, we use the </FONT><B><FONT face="Courier" size="5">.data</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> directive. This directive is required when memory variables are used in a program. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<P align="JUSTIFY">The instructions</P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>			mov	ax, @data</P>
<P>			mov	ds, ax</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">are concerned with accessing memory variables and must be used with programs that use memory variables. See textbook for further information.</P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The </FONT><B><I><FONT face="Courier" size="5">offset</FONT></I></B><I><FONT face="Courier" size="5"></FONT></I><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> operator allows us to access the address of a variable. In this case, we use it to access the address of </FONT><FONT face="Courier" size="5">message</FONT><FONT face="Times" size="5"> and we store this address in the </FONT><FONT face="Courier" size="5">dx</FONT><FONT face="Times" size="5"> register. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">Subprogram </FONT><FONT face="Courier" size="5">9h</FONT><FONT face="Times" size="5"> can access the string </FONT><FONT face="Courier" size="5">message</FONT><FONT face="Times" size="5"> (or any string), once it has been passed the starting address of the string.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Times"><P align="JUSTIFY">&nbsp;</P>
</FONT><B><FONT face="Times" size="5"><P align="JUSTIFY">Exercises</P>
<P align="JUSTIFY"></P>
</FONT></B><FONT face="Times" size="5"><P align="JUSTIFY">• Write a program to display ‘MS-DOS’ using (a) character output and (b) using string output.</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">• Write a program to display the message ‘Ding! Ding! Ding!’ and output ASCII code 7 three times. (ASCII code 7 is the Bel character. It causes your machine to beep! ).</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">• Write a program to beep, display ‘?’ as a prompt, read a character and display it on a new line. </P>
<P align="JUSTIFY"></P>
</FONT><FONT face="Times"><P align="JUSTIFY">&nbsp;</P>
<B><P align="JUSTIFY">&nbsp;</P>
</B></FONT><B><FONT face="Times" size="5"><P align="JUSTIFY">Control Flow Instructions: Subprograms </P>
</FONT></B><FONT face="Times" size="5"><P align="JUSTIFY">A subprogram allows us to give a <B>name</B> to a group of instructions and to use that name when we wish to execute those instructions, instead of having to write the instructions again. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">For example, the instructions to display a character could be given the name </FONT><FONT face="Courier" size="5">putc</FONT><FONT face="Times" size="5"> (or whatever you choose). Then to display a character you can use the name </FONT><FONT face="Courier" size="5">putc</FONT><FONT face="Times" size="5"> which will cause the appropriate instructions to be executed. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">This is referred to as <B>calling</B> the subprogram. In 8086 assembly language, the instruction </FONT><FONT face="Courier" size="5">call</FONT><FONT face="Times" size="5"> is used to invoke a subprogram, so for example, a </FONT><FONT face="Courier" size="5">putc</FONT><FONT face="Times" size="5"> subprogram would be called as follows:</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="4"><P>			call	putc		; Display character in dl</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
<P align="JUSTIFY">The process of giving a group of instructions a name is referred to as <B>defining</B> a subprogram. <B>This is only done once</B>. </P>
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">Definition of </FONT><FONT face="Courier" size="5">putc, getc and puts</FONT><FONT face="Times" size="5"> subprograms.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>putc:			; display character in dl</P>
<P>			mov	ah, 2h</P>
<P>			int	21h		</P>
<P>			ret</P>
</FONT><FONT face="Times" size="6"><P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>getc:			; read character into al</P>
<P>		mov	ah, 1h	</P>
<P>		int	21h			</P>
<P>		ret				</P>
<P>puts:			; display string terminated by $</P>
<P>				; dx contains address of string</P>
<P>		mov ah, 9h</P>
<P>		int 21h			</P>
<P>		ret</P>
</FONT><FONT face="Times" size="7"><P align="JUSTIFY"></P>
</FONT><B><FONT face="Times" size="5"></FONT><P><FONT face="Times" size="5">The </FONT><FONT face="Courier" size="6">ret</FONT><FONT face="Times" size="6"> </FONT><FONT face="Times" size="5">instruction terminates the subprogram and arranges for execution to resume at the instruction following the </FONT><FONT face="Courier" size="5">call</FONT><FONT face="Times" size="5"> instruction. </FONT></P><FONT face="Times" size="5">
</FONT></B><FONT face="Times" size="5">
<P>We usually refer to that part of a program where execution begins as the <B>main program</B>. </P>

<P>In practice, programs consist of a main program and a number of subprograms. It is important to note that subprograms make our programs easier to read, write and maintain even if we only use them once in a program.</P>

<B></B></FONT><P><FONT face="Times" size="5"><B>Note</B>: Subprograms are defined <B>after</B> the code to terminate the program, but <B>before</B> the </FONT><FONT face="Courier" size="5">end</FONT><FONT face="Times" size="5"> directive. </FONT></P><FONT face="Times" size="5">

<P>If we placed the subprograms earlier in the code, they would be executed without being called (execution would <I>fall through into</I> them). This should <B>not</B> be allowed to happen.</P>

<P>The following program illustrates the use of the above subprograms.</P>

</FONT><FONT face="Courier" size="4"><P>C&gt; sub</P>
<P>Enter a character: <B>x</B></P><B>
</B><P>You entered: x</P>
</FONT><FONT face="Courier" size="5">
<P>; subs.asm: Prompt user to enter a character</P>
<P>; and display the character entered</P>
<P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>

<P>		.model small</P>
<P>		.stack 100h</P>

<P>			.data</P>
<P>prompt		db		‘Enter a character: $‘</P>
<P>msgout		db		‘You entered: $‘</P>

<P>							 </P>
<P>			.code</P>
<P>start:		</P>
<P>			mov	ax, @data</P>
<P>			mov	ds, ax</P>

<P>; copy address of message to dx</P>
<P>		mov	dx, offset prompt</P>
<P>		call puts		; display prompt	</P>

<P>			call getc	; read character into al </P>
<P>			mov	bl, al	; save character in bl</P>

<P>;display next message</P>
<P>		mov	dx, offset msgout</P>
<P>		call puts		; display msgout	</P>

<P>; display character read from keyboard</P>
<P>		mov	dl, bl		; copy character to dl</P>
<P>		call putc</P>

<P>		mov	ax, 4c00h 		; return to ms-dos</P>
<P>		int	21h</P>

<P>; User defined Subprograms </P>
<P>putc:			; display character in dl</P>
<P>			mov	ah, 2h</P>
<P>			int	21h		</P>
<P>			ret</P>
</FONT><FONT face="Times" size="6"><P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>getc:			; read character into al</P>
<P>		mov	ah, 1h	</P>
<P>		int	21h			</P>
<P>		ret				</P>

<P>puts:			; display string terminated by $</P>
<P>				; dx contains address of string</P>
<P>		mov ah, 9h</P>
<P>		int 21h			</P>
<P>		ret</P>
<P>		end		start</P>
</FONT><FONT face="Times"><P align="JUSTIFY"></P>
</FONT><B><FONT face="Times" size="5"><P align="JUSTIFY">Defining Constants: <I>Macros</I></P><I>
</I></FONT></B><FONT face="Times" size="5"><I></I><P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The </FONT><B><FONT face="Courier" size="5">equ</FONT></B><FONT face="Courier" size="5"></FONT><FONT face="Times" size="5"> directive is used to define constants. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">For example if we wish to use the names </FONT><FONT face="Courier" size="5">CR</FONT><FONT face="Times" size="5"> and </FONT><FONT face="Courier" size="5">LF</FONT><FONT face="Times" size="5">, to represent the ASCII codes of Carriage Return and Line-feed, we can use this directive to do so. </FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>CR	equ	13d</P>
<P>LF	equ	10d</P>
<P>MAX	equ 1000d</P>
<P>MIN	equ 0</P>
</FONT><FONT face="Courier">
</FONT><FONT face="Times" size="5"><P align="JUSTIFY">&nbsp;</P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">The assembler, replaces all occurrences of </FONT><FONT face="Courier" size="5">CR</FONT><FONT face="Times" size="5"> with the number 13 before the program is translated to machine code. It carries out similar replacements for the other constants.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
</FONT><P align="JUSTIFY"><FONT face="Times" size="5">Essentially, the </FONT><FONT face="Courier" size="5">equ</FONT><FONT face="Times" size="5"> directive provides a text substitution facility. One piece of text (</FONT><FONT face="Courier" size="5">CR</FONT><FONT face="Times" size="5">) is replaced by another piece of text (13), in your program. Such a facility is often call a <B>macro</B> facility.</FONT></P><FONT face="Times" size="5">
<P align="JUSTIFY"></P>
<P align="JUSTIFY">We use constants to make our programs easier to read and understand.</P>
<P align="JUSTIFY"></P>
<P align="JUSTIFY">&nbsp;</P>
<B></B><P align="JUSTIFY"><B>Example 3.18: </B>The following program, displays the message ‘Hello World’, and uses the equ directive.</P>
</FONT><FONT face="Times" size="5"><P align="JUSTIFY"></P>
</FONT><FONT face="Courier" size="5"><P>; io9.asm: Display the message ‘Hello World’ </P>
<P>; Author:	Joe Carthy</P>
<P>; Date:	March 1994</P>

<P>		.model small</P>
<P>		.stack 100h</P>
<P>		.data</P>

<B><P>CR 		equ	13d</P>
<P>LF		equ	10d</P>
</B>
<P>message	db		‘Hello World’, CR, LF, ‘$’</P>

<P>		.code</P>
<P>start:		</P>
<P>		mov	ax, @data</P>
<P>		mov	ds, ax</P>

<P>		mov	dx, offset message</P>
<P>		call	puts			; display message</P>

<P>		mov	ax, 4c00h</P>
<P>		int 	21h</P>

<P>; User defined subprograms</P>

<P>puts:		; display a string terminated by $</P>
<P>			; dx contains address of string</P>
<P>		mov ah, 9h</P>
<P>		int 21h			; output string</P>
<P>		ret</P>

<P>		end		start</P>
</FONT><FONT face="Times"></FONT>

</BODY></HTML>